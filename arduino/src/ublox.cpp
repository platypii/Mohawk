#include <Arduino.h>
#include "mohawk.h"
#include "ublox.h"

const uint8_t UBLOX_BAUD[] PROGMEM = {
  // UBX-CFG-PRT baudrate 115200 = 0x01c200
  // header   class id    len   port        txReady     mode                    baud                    in mask     out mask    flags
  0xb5, 0x62, 0x06, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0xd0, 0x08, 0x00, 0x00, 0x00, 0xc2, 0x01, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc4, 0x96,
//0xb5, 0x62, 0x06, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0xd0, 0x08, 0x00, 0x00, 0x00, 0xc2, 0x01, 0x00, 0x07, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x7e,
//0xb5, 0x62, 0x06, 0x00, 0x01, 0x00, 0x01, 0x08, 0x22
};

const uint8_t UBLOX_INIT[] PROGMEM = {
  // UBX-CFG-RATE
  // header   class id    len
  0xb5, 0x62, 0x06, 0x08, 0x06, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x01, 0x39, // 1 Hz
  // 0xb5, 0x62, 0x06, 0x08, 0x06, 0x00, 0xc8, 0x00, 0x01, 0x00, 0x01, 0x00, 0xde, 0x6a, // 5 Hz
  // 0xb5, 0x62, 0x06, 0x08, 0x06, 0x00, 0x64, 0x00, 0x01, 0x00, 0x01, 0x00, 0x7a, 0x12, // 10 Hz
  // UBX-CFG-MSG
  // header   class id    len
  0xb5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x24, // GGA off
  0xb5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x2b, // GLL off
  0xb5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xf0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x32, // GSA off
  0xb5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x39, // GSV off
  0xb5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xf0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x40, // RMC off
  0xb5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xf0, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x47, // VTG off
  0xb5, 0x62, 0x06, 0x01, 0x08, 0x00, 0x01, 0x07, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x18, 0xe1, // NAV-PVT on
  // 0xb5, 0x62, 0x06, 0x01, 0x08, 0x00, 0x01, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x13, 0xbe, // NAV-POSLLH on
  // 0xb5, 0x62, 0x06, 0x01, 0x08, 0x00, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x14, 0xc5, // NAV-STATUS on
  // UBX-CFG-CFG save to persistent memory
  // header      class id    len   clear       save        load
  // 0xb5, 0x62, 0x06, 0x09, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static long long parse_date(NAV_PVT *pvt);

void ublox_init() {
  // Secondary serial port, since primary interferes with programming
  // Init at 9600, send 115200 command, switch to 115200
  Serial2.begin(9600, SERIAL_8N1, PIN_GPS_TX, PIN_GPS_RX);
  Serial2.write(UBLOX_BAUD, sizeof(UBLOX_BAUD));
  Serial2.flush();
  Serial2.updateBaudRate(115200);
  Serial2.write(UBLOX_INIT, sizeof(UBLOX_INIT));
}

void parse_ublox(char *buffer) {
  // Serial.printf("UBX: %x %x %x %x\n", buffer[0], buffer[1], buffer[2], buffer[3]);
  if (buffer[0] == 0xb5 && buffer[1] == 0x62) {
    NAV_PVT *pvt = (NAV_PVT *) (buffer + 2);
    if (pvt->cls != 1 || pvt->id != 7) {
      Serial.printf("Unexpected ublox message %x %x\n", pvt->cls, pvt->id);
    }
    const long long millis = parse_date(pvt);
    GeoPointV *point = new GeoPointV {
      .millis = millis,
      .lat = pvt->lat * 1e-7,
      .lng = pvt->lon * 1e-7,
      .alt = pvt->hMSL * 1e-3, // mm
      .climb = -pvt->velD * 1e-3, // mm/s
      .vN = pvt->velN * 1e-3, // mm/s
      .vE = pvt->velE * 1e-3 // mm/s
    };
    update_location(point);
  } else {
    Serial.printf("Invalid UBX header: %x %x %s\n", buffer[0], buffer[1], buffer);
  }
}

static long long parse_date(NAV_PVT *pvt) {
  struct tm date;
  date.tm_hour = pvt->hour;
  date.tm_min = pvt->minute;
  date.tm_sec = pvt->second;
  date.tm_isdst = 0;
  date.tm_mday = pvt->day;
  date.tm_mon = pvt->month - 1;
  date.tm_year = pvt->year - 1900; // years since 1900
  return mktime(&date) * 1000LL + pvt->nano * 1e-6;
}
